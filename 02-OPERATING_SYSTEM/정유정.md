## 운영체제

# 1. 시스템콜
<details><summary>시스템 콜이 무엇인지 설명해 주세요.</summary></details>
<details><summary>우리가 사용하는 시스템 콜의 예시를 들어주세요.</summary></details>
<details><summary>시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.</summary></details>
<details><summary>시스템 콜의 유형에 대해 설명해 주세요.</summary></details>
<details><summary>운영체제의 Dual Mode 에 대해 설명해 주세요.</summary></details>
<details><summary>왜 유저모드와 커널모드를 구분해야 하나요?</summary></details>
<details><summary>서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?</summary></details>

# 2. 인터럽트
<details><summary>인터럽트가 무엇인지 설명해 주세요.</summary></details>
<details><summary>인터럽트는 어떻게 처리하나요?</summary></details>
<details><summary>Polling 방식에 대해 설명해 주세요.</summary></details>
<details><summary>HW / SW 인터럽트에 대해 설명해 주세요.</summary></details>
<details><summary>동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요? </summary></details>

# 3. 프로세스

<details><summary>프로세스가 무엇인가요?</summary></details>
<details><summary>프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.</summary></details>
<details><summary>PCB가 무엇인가요?</summary></details>
<details><summary>그렇다면, 스레드는 PCB를 갖고 있을까요?</summary></details>
<details><summary>리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?</summary></details>
<details><summary>자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?</summary></details>
<details><summary>리눅스에서, 데몬프로세스에 대해 설명해 주세요.</summary></details>
<details><summary>리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.</summary></details>

# 4. 프로세스의 주소공간

<details><summary>프로세스 주소공간에 대해 설명해 주세요.</summary></details>
<details><summary>초기화 하지 않은 변수들은 어디에 저장될까요?</summary></details>
<details><summary>일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?</summary></details>
<details><summary>Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?</summary></details>
<details><summary>다음과 같이 공간을 분할하는 이유가 있을까요?</summary></details>
<details><summary>스레드의 주소공간은 어떻게 구성되어 있을까요?</summary></details>
<details><summary>"스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.</summary></details>
<details><summary>IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요? </summary></details>
<details><summary>스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요? </summary></details>

# 5. 스케쥴링

<details><summary>단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.</summary></details>
<details><summary>현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?</summary></details>
<details><summary>프로세스의 스케쥴링 상태에 대해 설명해 주세요.</summary></details>
<details><summary>preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?</summary></details>
<details><summary>Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?</summary></details>


# 6. 컨텍스트 스위칭

<details><summary>컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?</summary></details>
<details><summary>프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?</summary></details>
<details><summary>컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?</summary></details>
<details><summary>컨텍스트 스위칭은 언제 일어날까요?</summary></details>

# 7. 프로세스 스케줄링 알고리즘

<details><summary>프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?</summary></details>
<details><summary>RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.</summary></details>
<details><summary>싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?</summary></details>
<details><summary>동시성과 병렬성의 차이에 대해 설명해 주세요.</summary></details>
<details><summary>타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?</summary></details>
<details><summary>FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요? </summary></details>
<details><summary>우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?</summary></details>
<details><summary>유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?</summary></details>

# 8. 뮤텍스와 세마포어
<details><summary>뮤텍스와 세마포어의 차이점은 무엇인가요?</summary></details>
<details><summary>이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.</summary></details>
<details><summary>Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?</summary></details>
<details><summary>뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?</summary></details>

# 9. 데드락
<details><summary>Deadlock 에 대해 설명해 주세요.</summary></details>
<details><summary>Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.</summary></details>
<details><summary>그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?</summary></details>
<details><summary>어떤 방식으로 예방할 수 있을까요?</summary></details>
<details><summary>왜 현대 OS는 Deadlock을 처리하지 않을까요?</summary></details>
<details><summary>Wait Free와 Lock Free를 비교해 주세요.</summary></details>


# 10. 컴파일
<details><summary>프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.</summary></details>
<details><summary>링커와, 로더의 차이에 대해 설명해 주세요.</summary></details>
<details><summary>컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.</summary></details>
<details><summary>JIT에 대해 설명해 주세요.</summary></details>
<details><summary>본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.</summary></details>
<details><summary>Python 같은 언어는 CPython, Jython, PyPy등의 다양한 구현체가 있습니다. 각각은 어떤 차이가 있을까요? 또한, 실행되는 과정 또한 다를까요?</summary></details>
<details><summary>우리는 흔히 fork(), exec() 시스템 콜을 사용하여 프로세스를 적재할 수 있다고 배웠습니다. 로더의 역할은 이 시스템 콜과 상관있는 걸까요? 아니면 다른 방식으로 프로세스를 적재할 수 있는 건가요?</summary></details>

# 11. IPC
<details><summary>IPC가 무엇이고, 어떤 종류가 있는지 설명해 주세요.</summary></details>
<details><summary>Shared Memory가 무엇이며, 사용할 때 유의해야 할 점에 대해 설명해 주세요.</summary></details>
<details><summary>메시지 큐는 단방향이라고 할 수 있나요?</summary></details>

# 12. Thread Safe

<details><summary>Thread Safe 하다는 것은 어떤 의미인가요?</summary></details>
<details><summary>Thread Safe 를 보장하기 위해 어떤 방법을 사용할 수 있나요?</summary></details>
<details><summary>Peterson's Algorithm 이 무엇이며, 한계점에 대해 설명해 주세요.</summary></details>
<details><summary>Race Condition 이 무엇인가요?</summary></details>
<details><summary>Thread Safe를 구현하기 위해 반드시 락을 사용해야 할까요? 그렇지 않다면, 어떤 다른 방법이 있을까요?</summary></details>

# 13. Thread Safe(2)
<details><summary>Thread Pool, Monitor, Fork-Join에 대해 설명해 주세요.</summary></details>
<details><summary>Thread Pool을 사용한다고 가정하면, 어떤 기준으로 스레드의 수를 결정할 것인가요? </summary></details>
<details><summary>어떤 데이터를 정렬 하려고 합니다. 어떤 방식의 전략을 사용하는 것이 가장 안전하면서도 좋은 성능을 낼 수 있을까요?</summary></details>


# 14. 캐시
<details><summary>캐시 메모리 및 메모리 계층성에 대해 설명해 주세요.</summary></details>
<details><summary>캐시 메모리는 어디에 위치해 있나요?</summary></details>
<details><summary>L1, L2 캐시에 대해 설명해 주세요.</summary></details>
<details><summary>캐시에 올라오는 데이터는 어떻게 관리되나요?</summary></details>
<details><summary>캐시간의 동기화는 어떻게 이루어지나요?</summary></details>
<details><summary>캐시 메모리의 Mapping 방식에 대해 설명해 주세요.</summary></details>
<details><summary>캐시의 지역성에 대해 설명해 주세요.</summary></details>
<details><summary>캐시의 지역성을 기반으로, 이차원 배열을 가로/세로로 탐색했을 때의 성능 차이에 대해 설명해 주세요.</summary></details>
<details><summary>캐시의 공간 지역성은 어떻게 구현될 수 있을까요? (힌트: 캐시는 어떤 단위로 저장되고 관리될까요?) </summary></details>

# 15. 메모리의 연속할당

<details><summary>메모리의 연속할당 방식 세 가지를 설명해주세요. (first-fit, best-fit, worst-fit)</summary></details>
<details><summary>worst-fit 은 언제 사용할 수 있을까요?</summary></details>
<details><summary>성능이 가장 좋은 알고리즘은 무엇일까요?</summary></details>


# ^ ToDo..

---

# 16. Thrashing

<details>
<summary>Thrashing 이란 무엇인가요?</summary>

- Thrashing은 운영체제에서 프로세스들이 원활히 동작하기 위한 충분한 페이지 프레임 개수를 확보하지 못해, 과도한 페이지 폴트가 발생하고 실제 연산보다 페이지 교체(스왑인/아웃) 작업에 대부분의 시스템 리소스가 소모되는 현상입니다.
- 이러한 상황에서는 CPU 이용률이 급격히 저하되고, 시스템 응답성이 극단적으로 떨어집니다.

</details>

<details>
<summary>Thrashing 발생 시, 어떻게 완화할 수 있을까요?</summary>

- 메모리 부족이 원인이므로 Thrashing 완화 방법에는 프로세스별 할당 가능 페이지 프레임 수를 늘리거나, 
- 시스템의 다중 프로그래밍 정도(동시에 실행되는 프로세스 수)를 줄이거나, 
- 효율적인 페이지 교체 알고리즘(LRU 등)을 선택하는 등의 방식이 있습니다.

</details>

# 17. VM
<details>
<summary>가상 메모리란 무엇인가요?</summary>

- 가상 메모리는 물리적인 메모리(RAM)의 용량 부족 문제를 극복하기 위해 필요한 메모리 관리 기법입니다.
- RAM에 다 올릴 수 없는 대규모 프로그램도 디스크의 일부를 RAM의 보조기억장치처럼 활용해, 전체를 메모리에 올리지 않고 필요한 부분(페이지)만 실시간으로 불러와 실행이 가능합니다.

</details>

<details>
<summary>가상 메모리가 가능한 이유가 무엇일까요?</summary>

- 프로세스가 실행될 때 전체가 메모리에 올라가지 않아도 실행이 가능하기 때문입니다. 
- 운영체제는 프로그램을 페이지 단위로 나누고, 필요한 페이지만 메모리에 적재합니다. 이때 CPU의 MMU가 가상 주소를 물리 주소로 변환하고, 운영체제가 페이지 교체를 관리하면서 디스크를 보조 메모리처럼 활용할 수 있게 됩니다.

</details>

<details>
<summary>Page Fault가 발생했을 때, 어떻게 처리하는지 설명해 주세요.</summary>

- 페이지 폴트 발생 시, 빈 프레임이 있으면 해당 페이지를 메모리에 적재하고
- 빈 프레임이 없으면 페이지 교체 알고리즘을 사용해 희생 프레임을 선택, 내용을 디스크로 내보낸 뒤(스왑아웃) 새 페이지를 적재

</details>

<details>
<summary>페이지 크기에 대한 Trade-Off를 설명해 주세요.</summary>

- 큰 페이지: 페이지 테이블이 작아져 효율적이지만, 내부 단편화가 증가
- 작은 페이지: 단편화는 줄지만 페이지 테이블이 커지고, 관리 비용이 증가

</details>

<details>
<summary>페이지 크기가 커지면, 페이지 폴트가 더 많이 발생한다고 할 수 있나요?</summary>

- 페이지 크기가 커지면 초기에는 페이지가 쓰이지 않는 불필요한 코드까지 포함해 페이지폴트가 증가할 수 있지만, 
- 일정 크기에 도달하면 한 페이지에 필요한 코드가 대부분 포함되어 오히려 감소할 수 있습니다.

</details>
<details>
<summary>세그멘테이션 방식을 사용하고 있다면, 가상 메모리를 사용할 수 없을까요?</summary>

- 가상 주소를 세그먼트 번호와 오프셋으로 표현하고, 필요한 세그먼트만 디스크에서 메모리로 불러오는 방식으로 가상 메모리를 운영할 수 있습니다.
- 다만 세그멘테이션 방식에선 외부 단편화가 발생하고, 세그먼트 단위로 메모리를 관리해야 하므로 구현이 더 복잡해지므로 실제로는 페이징과 결합한 혼합 방식으로 사용합니다. 

</details>

# 18. 페이징
<details>
<summary>세그멘테이션과 페이징의 차이점은 무엇인가요?</summary>

- Segmentation: 메모리를 논리적 단위(함수, 자료구조 등)인 세그먼트 단위로 나누는 방식입니다. 
  - 각 세그먼트는 크기가 유동적이기 때문에 내부 단편화는 적지만,
  - 메모리 내 연속 공간 확보가 필요하므로 외부 단편화가 발생할 수 있습니다.
- Paging: 메모리를 고정 크기의 페이지 단위로 나누는 방식입니다. 
  - 마지막 페이지의 일부가 비어 있을 수 있어 내부 단편화가 발생할 수 있으나
  - 연속적인 공간을 요구하지 않아 외부 단편화는 없습니다.
</details>

<details>
<summary>페이지와 프레임의 차이에 대해 설명해 주세요.</summary>

- 페이지는 프로세스를 일정 크기로 나눈 단위이고, 
- 프레임은 물리 메모리를 같은 크기로 나눈 단위입니다.
</details>

<details>
<summary>내부 단편화와, 외부 단편화에 대해 설명해 주세요.</summary>

- 내부 단편화: 프레임보다 작은 페이지가 할당될 때 생기는 남는 공간입니다.
- 외부 단편화: 연속된 메모리 공간이 부족해 전체 공간이 있어도 할당이 불가능한 상태입니다.

</details>

<details>
<summary>페이지에서 실제 주소를 어떻게 가져올 수 있는지 설명해 주세요.</summary>

- 논리 주소 = (페이지 번호, 오프셋)
- 페이지 번호로 페이지 테이블에서 프레임의 시작 주소를 찾고, 여기에 오프셋을 더해 실제 물리 주소를 계산합니다.

</details>

<details>
<summary>어떤 주소공간이 있을 때, 이 공간이 수정 가능한지 확인할 수 있는 방법이 있나요?</summary>

- 페이지 테이블의 각 엔트리에 Read/Write, Valid/Invalid 등 권한 정보가 추가되어 있습니다.
- read-only 비트가 설정되어 있으면 해당 영역은 수정할 수 없습니다. 

</details>

<details>
<summary>32비트에서, 페이지의 크기가 1kb 이라면 페이지 테이블의 최대 크기는 몇 개일까요?</summary>

- 32비트 → 주소공간 2³²
- 1KB → 페이지크기 2¹⁰
- 페이지 개수 = 주소공간 2³² / 페이지크기 2¹⁰ = 2²²개

</details>

<details>
<summary>32비트 운영체제는 램을 최대 4G 까지 사용할 수 있습니다. 이 이유를 페이징과 연관 지어서 설명해 주세요.</summary>

> 주소 버스는 CPU가 메모리 내 어느 위치(주소)에 접근할지 지정하는 신호선을 의미합니다. 이 주소 버스의 폭(비트 수)은 한 번에 지정할 수 있는 주소의 범위를 결정합니다.
- 주소 버스가 32비트일 때 지정할 수 있는 가상 주소 공간은 2³²바이트, 즉 4GB입니다.
- 페이징은 이 가상 주소 공간을 일정 크기의 페이지 단위로 분할하고, 각 페이지를 물리 메모리의 프레임과 매핑하는 구조입니다. 프로세스가 4GB 가상 주소 공간 내에서 접근하는 주소는 모두 페이징 매커니즘을 거쳐 실제 물리 메모리의 위치로 변환됩니다. 이 때문에 32비트 운영체제는 가상 주소 공간 최대 크기 자체가 4GB로 제한되어, 프로세스가 사용할 수 있는 메모리 용량도 4GB를 넘을 수 없습니다.

</details>

<details>
<summary>C/C++ 개발을 하게 되면 Segmentation Fault 라는 에러를 접할 수 있을텐데, 이 에러는 세그멘테이션/페이징과 어떤 관계가 있을까요? </summary>

- 운영체제는 세그멘테이션과 페이징을 통해 각 메모리 영역에 접근 권한을 설정하고, 허용되지 않은 접근을 차단합니다. 
- 세그멘테이션은 코드, 데이터, 스택 등을 구분하고, 영역별 접근을 제어합니다. 
- 페이징은 페이지마다 읽기/쓰기 가능 여부를 지정하고, 유효하지 않은 접근을 감지합니다. 
- C/C++에서 잘못된 포인터 사용이나 NULL 참조처럼 허용되지 않은 주소에 접근하면, 운영체제가 이를 감지하고 Segmentation Fault를 발생시킵니다.

</details>

# 19. TLB, MMU
<details><summary>TLB는 무엇인가요?</summary></details>
<details><summary>TLB를 쓰면 왜 빨라지나요?</summary></details>
<details><summary>MMU가 무엇인가요?</summary></details>
<details><summary>TLB와 MMU는 어디에 위치해 있나요?</summary></details>
<details><summary>코어가 여러개라면, TLB는 어떻게 동기화 할 수 있을까요? </summary></details>
<details><summary>TLB 관점에서, Context Switching 발생 시 어떤 변화가 발생하는지 설명해 주세요. </summary></details>

# 20. 동기화를 구현하기 위한 하드웨어적인 해결 방법
<details><summary>동기화를 구현하기 위한 하드웨어적인 해결 방법에 대해 설명해 주세요.</summary></details>
<details><summary>volatile 키워드는 어떤 의미가 있나요?</summary></details>
<details><summary>싱글코어가 아니라 멀티코어라면, 어떻게 동기화가 이뤄질까요?</summary></details>

# 21. 페이지 교체 알고리즘
<details><summary>페이지 교체 알고리즘에 대해 설명해 주세요.</summary></details>
<details><summary>LRU 알고리즘은 어떤 특성을 이용한 알고리즘이라고 할 수 있을까요?</summary></details>
<details><summary>LRU 알고리즘을 구현한다면, 어떻게 구현할 수 있을까요?</summary></details>
<details><summary>LRU 알고리즘의 단점을 설명해 주세요. 이를 해결할 수 있는 대안에 대해서도 설명해 주세요.</summary></details>

# 22. File Descriptor와 File System
<details><summary>File Descriptor와, File System에 에 대해 설명해 주세요.</summary></details>
<details><summary>I-Node가 무엇인가요?</summary></details>
<details><summary>프로그래밍 언어 상에서 제공하는 파일 관련 함수 (Python - open(), Java - BufferedReader/Writer 등)은, 파일을 어떤 방식으로 읽어들이나요?</summary></details>

# 23. 동기와 비동기, 블로킹과 논블로킹
<details><summary>동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해 주세요.</summary></details>
<details><summary>그렇다면, 동기이면서 논블로킹이고, 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요?</summary></details>
<details><summary>I/O 멀티플렉싱에 대해 설명해 주세요.</summary></details>
<details><summary>논블로킹 I/O를 수행한다고 하면, 그 결과를 어떻게 수신할 수 있나요</summary></details>