# Java, Spring

## 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.

<details>
<summary>JVM의 정의와 기능</summary>

- JVM(Java Virtual Machine): 자바 바이트코드를 실행하기 위한 가상 머신.
  - 주요 구성 요소: 클래스 로더(class loader), 실행 엔진(execution engine), 런타임 데이터 영역(Runtime Data Areas)
  - 자바 컴파일러(javac)가 .java → 바이트 코드(.class)로 반환, JVM이 바이트 코드를 실행.
- 클래스 로딩(메모리로 로딩), 보안, 실행 엔진, 메모리 관리, 표준 라이브러리 접근 등의 기능을 수행한다.
- Java 프로그램이어떤 운영체제(OS)에서도 동일하게 작동할 수 있게 한다.
  - Java 바이트코드: JVM이 이해할 수 있는 언어로 번역된 Java 소스 코드를 의미.
- [답변 참고](https://peonyf.tistory.com/entry/JVM)
</details>

<details>
<summary>그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?</summary>

- JVM은 Java 전용이 아닌, JVM 바이트코드를 실행한다. Java 바이트코드로 변환이 가능하다면 다른 언어도 실행할 수 있다.
- 대표적으로, Kotlin, Scala, Groovy 등이 JVM 위에서 실행될 수 있다.
- 이러한 언어들은 각자의 특성을 가지고 있지만, JVM 위에서 실행되므로 Java의 라이브러리와 프레임워크를 활용할 수 있고, JVM의 메모리 관리와 성능 최적화 같은 기능을 이용할 수 있다.

</details>

<details>
<summary>반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?</summary>

- 가능할 수는 있지만 제한적이다. JVM 언어로 작성된 코드를 JVM 바이트코드가 아닌 네이티브 코드로 직접 컴파일하려면, 해당 언어를 지원하는 AOT(ahead-of-time) 컴파일러나 별도
- JVM이 제공하는 이식성과 런타임 기능(GC, 리플렉션 등) 일부를 잃을 수 있어 JVM의 장점을 활용하기 어렵다.
</details>

<details>
<summary>VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</summary>

**장점**

- 이식성: VM은 OS/하드웨어의 세부 사항을 추상화하여, OS/하드웨어에 관계없이 실행 가능하도록 한다. 예를 들어, JVM은 자바 프로그램을 모든 JVM이 설치된 프로그램에서 실행할 수 있게 해준다.
- 보안: VM은 바이트코드 검증(실행 전 코드의 무결성, 안전성 확인), 샌드박스 환경 제공(프로그램이 시스템 작원에 직접 접근하지 못하게 처리) 등의 기능을 수행한다.
- 메모리 관리 자동화: 자동 메모리 관리와 가비지 컬렉션 기능(사용하지 않는 객체 메모리를 자동 해제)을 제공한다.

**단점**

- 추가 자원 사용: VM은 자체적인 운영 체제와 런타임 시스템을 유지하기 때문에 추가적인 메모리와 CPU 리소스 자원을 사용하게 된다.
- 속도: VM을 거쳐 코드를 실행하는 것은 일반적으로 네이티브 앱보다 느릴 수 있지만, 최근에는 최적화를 통해 속도 격차가 줄어들고 있다.
</details>

<details>
<summary>JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?</summary>

- JVM 자체는 하나의 OS 프로세스이고, JVM 안에서 실행되는 Java 프로그램은 JVM 프로세스 내부의 스레드 형태로 동작한다.
- 일반적인 운영 체제의 프로세스 계층 관계를 고려할 때, JVM과 그 내부에서 실행되고 있는 프로그램은 부모-자식 관계라고 보기보다는, 단일 프로세스 내에서 스레드를 통해 동시에 작업을 처리하는 구조라고 볼 수 있다.
</details>

## 2. final 키워드를 사용하면, 어떤 이점이 있나요?</h3></summary>

<details>
<summary>final 키워드를 사용하면, 어떤 이점이 있나요?</summary>

- Java에서의 final: 불변성이 보장되고, 변경 가능성을 최소화하며, thread-safe(스레드 안정성)하기 때문에 동기화할 필요가 없다.
- 파라미터에 사용: 메서드 내에서 파라미터 재할당을 방지
- 변수에 사용: 객체 생성 후 의도치 않은 상태 변경, 재할당을 방지
- 메서드에 사용: 의도치 않은 오버라이딩 불가능 보장
- 클래스에 사용: 상속 불가능 보장

</details>

<details>
<summary>그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?</summary>

1. 컴파일러의 처리

- 컴파일 타임 상수로 결정 가능한 final 변수는 초기화된 후 값이 변경되지 않는 상수로 취급된다.
- 이 경우 컴파일러는 final 변수를 constant poll(상수 풀)에 넣거나, 코드 내에서 인라인되는 최적화를 수행할 수 있다.
- 컴파일러는 final 변수를 constant poll(상수 풀)에 넣거나, 상수로 치환하는 최적화를 수행할 수 있다.

2. JVM의 처리

- final 메서드/클래스의 경우 오버라이딩/상속이 불가능하다는 점을 JVM이 활용해 dynamic dispatch를 피할 수 있다. 따라서, JIT 컴파일러가 메서드 호출을 직접 호출로 최적화하거나, 인라이닝 할 수 있다.
- final 필드의 경우 한 번 초기화 이후 변경되지 않으므로, JVM이 불변성을 가정하고 최적화를 적용할 수 있다.
</details>

## 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.

<details>
  <summary>인터페이스와 추상 클래스의 차이</summary>

- 인터페이스와 추상 클래스 모드 추상 메서드를 가질 수 있으며, 추상화를 제공한다.

**인터페이스**

- "이 객체가 어떤 동작을 할 수 있는가?" 를 정의.
- 기본적으로 추상 메서드만 가진다.
- 생성자를 가질 수 없다.
- public static final(상수)만 변수 선언 가능하다.
- 다중 구현이 가능하다.
- Comparable, Runnable 등 → 객체의 역할/행동 규약을 명세.

**추상 클래스**

- "이 객체는 무엇인가?" 를 정의.
- 일반 메서드와 추상 메서드 둘다 사용 가능하다.
- 생성자를 가질 수 있다.
- 당야한 종류의 변수 및 접근 제어자를 가질 수 있다.
- 단일 상속만 가능하다.
- 공통 속성과 메서드를 제공하면서, 세부 구현은 자식 클래스에 위임.

</details>

<details>
  <summary>왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?</summary>

- 클래스에 다중 구현을 가능하게 설정한다면:
  - 클래스는 상태(필드)와 구현(메서드 로직)을 모두 포함한다.
  - 다중 상속을 허용하면 다이아몬드 문제(Diamond Problem)가 발생할 수 있다.
  - 예시) A를 상속한 B와 C, D가 B와 C를 동시에 상속한다면 D가 A를 어떻게 물려받을지에 대한 문제
- 인터페이스는 본질적으로 행동(메서드 시그니처, 규약)을 정의하는 역할.
  - 충돌 가능성이 낮아 다중 구현이 허용. 충돌 발생 시 강제로 해결하도록 설정.
  - Java 8 이후 default 메서드가 생기면서 구현이 가능해졌지만, 구현 클래스에서 명시적으로 해결하도록 강제함.
  </details>

## 4. 리플렉션에 대해 설명해 주세요.

<details>
  <summary>리플렉션이란?</summary>

- 자바 리플렉션은 런타인 시점에서 클래스, 메서드, 필드, 생성자 등의 메타데이터에 동적으로 접근할 수 있는 기능을 제공하는 자바 API이다.
- Java에서는 컴파일러가 .java -> byte 코드로 변경, 클래스 로더는 해당 코드를 읽어 JVM 메모리 영역에 저장한다.
- 리플렉션은 이 JVM 메모리 영역에 저장된 클래스의 정보를 꺼내와서 사용한다.
- 장점: 유연성과 확장성이 증가하고, 외부 라이브러리 없이도 런타임에 클래스 정보를 얻거나, 메서드를 호출하고, 속성을 변경할 수 있다.
- 예시)
  - 스프링 프레임워크: DI에 사용
  - MVC: View에서 넘어오는 데이터를 객체에 바인딩할 때 사용
  - Hibernate: @Entity 클래스에 setter가 없으면 해당 필드에 값을 바로 주입
  - JUnit: ReflectionUtils 라는 클래스를 내부적으로 정의하여 사용
- 추가 질문) 생성자 주입이 빈을 생성할 때 추가적인 리플렉션을 진행하는가?
  - 일반적으로 생성자 주입이 일어날 때 리플렉션은 빈 생성 과정에서 한 번 수행된다. 그러나 AOP와 같은 기능, 프록시 객체를 생성할 때는 추가적인 리플렉션을 진행할 수 있다.
  </details>

<details>
  <summary>의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?</summary>

- 리플렉션의 주요 보안 위험: 캡슐화 위반(private로 설정한 필드에도 접근 가능), 접근 제어 우회 가능성, 불변 객체 변조 가능성이 있다.
- 외에도 성능 저하를 발생시킬 수 있다는 단점이 존재한다.
- 방지 방법:
  - 최소 권한 원칙: 꼭 필요한 경우에만 사용한다.
  - SecurityManager 활용: Java의 SecurityManager를 활용하면 보안 정책을 더 세밀하게 지어할 수 있다. 민감한 패키지에 대한 리플렉션 접근을 제한한다.
  - 코드 검사와 테스트: 리플렉션을 사용하는 부분에서 예기치 않은 동작이 발생하지 않도록 주의해야 함.
  </details>

<details>
  <summary>리플렉션을 언제 활용할 수 있을까요?</summary>

- 프레임워크/라이브러리 개발: 스프링(Spring), 하이버네이트(Hibernate) 같은 프레임워크들은 리플렉션을 활용해 내부적으로 객체 생성, 메서드 호출, 필드 접근 등을 처리한다.
- 어노테이션 처리: AOP(관점 지향 프로그래밍), 유효성 검사, 로깅 등 다양한 곳에서 활용할 수 있다.
- 테스트 도구에서 활용: JUnit에서 테스트 메서드 자동 발견 및 실행, Mock 라이브러리에서 private 필드 주입
- 도구/유틸리티: Jackson, Gson 같은 라이브러리는 직렬화/역직렬화 시 객체의 필드 이름/타입을 런타임에 확인해서 매핑해준다.
</details>

## 5. static class와 static method를 비교해 주세요.

<details>
  <summary>static class와 static method</summary>

**static class**

- Java에서는 클래스 자체를 static으로 선언할 수 없고, 중첩 클래스(Nested class)에만 static을 붙일 수 있다.
  - static: static nested class
  - non-static: inner class
- Outer class를 인스턴스하지 않고 사용하는 클래스를 static class라고 한다.
- 외부 클래스와 인스턴스 없이 사용이 가능하다.
- 외부 클래스와 독립적으로 컴파일되고 로드될 수 잇다.
- 외부 클래스 참조가 없어 메모리 사용량이 줄어든다.

**static method**

- 인스턴스가 아니라 클래스에 속하는 메서드이다.
- 객체 생성 없이도 호출이 가능하다.
- 오버라이딩이 불가능하다.
- 유틸리티 메서드, 팩토리 메서드 등에 사용한다.
- 외부 인스턴스와 무관한 정적 중첩 클래스다.
</details>

<details>
  <summary>static을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?</summary>

**이점**

- 메모리 효율성: static 멤버(필드, 메서드, 클래스)는 JVM의 메서드 영역에 올라가고, 클래스 로딩 시 한 번만 메모리에 할당되어 메모리를 절약한다.
- 빠른 접근: 객체 생성 없이 클래스 이름으로 바로 접근할 수 있다.
- 전역적 성격: 어디서든 클래스명을 통해 접근할 수 있어 전역 상태나 유틸리티 기능에 적합하다.
- 초기화 보장: 클래스 로딩 시점에 초기화되어 멀티스레드 환경에서도 thread-safe한 초기화가 가능하다.
- 캡슐화 및 구조화 강화: static nested class를 사용하면 외부 클래스와 강하게 연관된 클래스를 한 곳에 묶을 수 있다.
- 추가 질문) DTO를 Nested Classes로 묶을 때 static을 붙이는 것이 좋은 이유는?
  - 메모리 공간, 생성 기간의 이점을 가질 수 있다.
  - Inner class의 경우 Inner class 가 Outer class 인스턴스에 대한 참조를 갖고 있기 때문에, Garbage Collection은 Outer class의 인스턴스를 수거 대상으로 보지 않아 GC 의 대상에서 제외한다.

**제약**

- 다형성 제한: static 메서드는 오버라이딩이 불가능하여 상속에서 다형성의 이점을 활용할 수 없다.
- 인스턴스 멤버 접근 불가: static 컨텍스트에서는 non-static 멤버(필드, 메서드 등)에 직접 접근할 수 없다.
- 테스트 어려움: 모킹(Mock)이나 DI(의존성 주입)이 어려워 단위 테스트가 복잡해진다.
- 메모리 누수 위험: static 변수는 GC 대상에서 쉽게 해제되지 않아 잘못 사용하면 메모리 누수가 발생할 수 있다.
- 스레드 안전성: static 변수는 모든 스레드가 공유하므로 동기화 문제가 발생할 수 있다.
</details>

<details>
  <summary>컴파일 과정에서 static이 어떻게 처리되는지 설명해 주세요.</summary>

- 클래스 로더에서 class 파일을 로딩하는 순서는 다음과 같이 3단계로 구성된다. (Loading → Linking → Initialization)

**1. Loading**

- 어떤 클래스가 처음으로 참조될 때, 클래스 로더가 .class 파일을 읽어 JVM 메모리(JVM의 메서드 영역)에 올린다.
- 이 시점에 아직 static 변수 값 초기화나 static 블록 실행은 일어나지 않는다.

**2. Linking**

- 클래스 파일을 사용하기 위해 검증, 준비를 하는 과정이다.
- static 변수에 메모리 공간을 할당하고 기본값(default value) 으로 초기화한다.

**3. Initialization**

- static 변수에 명시된 값이 대입되고, static 블록이 실행된다.
- 초기화는 클래스 로더당 단 한 번만 수행된다.
</details>

## 6. Java의 Exception에 대해 설명해 주세요.

<details>
 <summary>Java의 Exception이란?</summary>

- 정의: 프로그램 실행 중 발생할 수 있는 비정상적인 상황(에러 상태)를 객체로 표현한 것.
- 컴파일 시점에 발견되지 않다가, 프로그램이 실행되는 시점에서 발생한다.
- 메서드 내부에서 에러가 발생하면, 메서드는 객체를 만들고 런타임 시스템에 전달한다. 해당 객체는 "예외 객체"라고 불리며, 이를 예외 발생(throwing an excetpion)이라고 한다.
- Exception 전체 구조
- 최상위 클래스: `Throwable`
- `Error` : 개발자가 직접 처리 불가한 시스템적 에러
- `Exception` : 개발자가 처리할 수 있는 예외.
  - `Checked Exception` : 컴파일러가 처리 강제.
  - `Unchecked Exception`(RuntimeException) : 컴파일러가 강제하지 않음.

```

                 Throwable
                /         \
            Error          Exception
                          /        \
             (UncheckedException)   CheckedExceptions
               RuntimeException
```

</details>

<details>
  <summary>예외처리를 하는 세 방법에 대해 설명해 주세요.</summary>

**1. 예외 복구**

- 예외 상황을 파악하고 문제를 해결해서 정상상태로 돌려놓는 방법
- Exception이 발생하여도 어플리케이션은 정상적으로 동작
- 반복문을 이용하여 예외가 발생하더라도 일정 수만큼 재시도를 하여 예외 복구를 시도한다.
- 예시) try-catch 블록을 사용해서 catch 블록 안에서 예외 처리

**2. 예외처리 회피**

- 예외처리를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 방법(throws)
- 해당 계층에서 처리하는 게 적절하지 않은 경우 상위 계층에 책임을 위임한다.
- 해당 로직에서 예외가 발생했을 때 처리하지 않고 회피하는 것이 최선의 방법일 때만 사용한다.

**3. 예외 전환**

- 위의 예외 처리 회피와 비슷하게 메서드 밖으로 예외를 던지지만, 적절한 예외로 필터링해서 넘기는 방법이다.
- 조금 더 명확한 의미로 전달되기 위해 적합한 의미를 가진 예외로 변경해서 throws 하는 것이라 보면 된다.
- 이외에도 예외처리를 상위클래스로 단순하게 처리하기 위한 포장(wrap)하는 방법도 일컫는다.
- 예시) SQLException을 잡아서 CustomDataAccessException으로 변환 후 throw

</details>

<details>
  <summary>CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.</summary>

**Checked Exception (확인된 예외)**

- 컴파일 시점에 반드시 처리(try-catch 또는 throws 선언)해야 하는 예외.
- 주로 외부 지원(파일, 네트워크, DB 등)에서 발생하는 예외 상황이다.
- 예: IOException, SQLException.

**Unchecked Exception (확인되지 않은 예외, Runtime Exception)**

- 컴파일러가 강제하지 않음 → 예외 처리를 생략할 수 있음.
- 주로 프로그래밍 오류(코드 로직 오류)로 발생하는 예외.
- 예: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException.

**차이 정리**

- Checked: 외부 요인, 반드시 처리 필요.
- Unchecked: 로직 오류, 개발자가 선택적으로 처리.
</details>

<details>
  <summary>예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?</summary>

- 성능 영향
  - try-catch 블록 자체는 성능에 큰 영향을 주지 않지만, 실제로 예외가 발생하여 throw 되는 순간은 비용이 크다.
  - 스택 트레이스 캡처, 예외 객체 생성, 스택 언와인딩(unwind) 과정 때문에 속도 저하
- 부하 줄이는 방법
  - 사전 검증: if 문으로 null 체크, 범위 검사 등으로 예외가 발생하지 않도록 설계.
  - 예외 객체 최적화: Custom한 Exception의 경우엔 fillInStackTrace()를 오버라이드하여 stackTrace 생성 비용을 줄일 수 있음.
  - 대체 응답 반환: 예외 발생 대신 empty 객체를 리턴하거나 다른 적절한 응답으로 처리.
  - 로깅 최적화: 필요 이상으로 stack trace를 남기지 않고, 상황에 맞게 로깅 수준을 조정.
  - 성능 민감한 구간에서는 Checked Exception보다 Unchecked Exception + 사전 검증 활용.
  </details>

## 7. Synchronized 키워드에 대해 설명해 주세요.

<details>
  <summary>Synchronized 키워드란?</summary>

- 자바에서 동기화 영역을 생성하는 키워드.
- Synchronized 처리된 객체나 메서드는 두 개 이상의 스레드가 동시 접근하는 것을 막는다.
- 동시에 접근을 시도할 때는 Java 스레드 스케줄러가 스레드 우선순위, JVM 스케줄링 정책, Fairness 옵션에 의해 우선 순위를 선정한다.
- Synchronized의 특징
  - 스레드가 synchronized 키워드가 붙은 메서드에 진입하려면 해당 객체의 락을 획득해야 한다.
  - 여러 스레드가 대기 중인 경우, 락 획득 순서는 보장되지 않는다.
  - synchronized 블록 안에서는 변수의 메모리 가시성 문제가 자동으로 해결되므로, 별도의 volatile 선언이 필요하지 않다.
  </details>

<details>
  <summary>Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.</summary>

- 인스턴스 메서드:
  - synchronized 키워드를 메서드 선언에 붙이면, 해당 메서드를 호출한 인스턴스를 기준으로 동기화를 진행한다. 여러 스레드가 같은 객체의 synchronized 메서드를 호출하면 한 번에 하나만 실행한다.
  - 예시: `public synchronized void add(int value)`
- static 메서드:
  - 해당 클래스 레벨에서 동기화가 이루어진다.
  - 즉, 클래스 레벨에서 동기화가 걸려서 모든 인스턴스가 영향을 받는다.
  - 사용 시 주의: 클래스 객체는 JVM 내에서 하나만 존재하므로, 클래스 간 자원을 보호해야 할 때 적합하다.
  - 예시: `public static synchronized void add(int value)`
- 인스턴스 메서드 내부 블록:
  - 동기화가 필요한 코드만 블록으로 지정해, 특정 객체에 대해 lock을 걸 수 있다.
  - 예시:
    ```java
    public void add(int value) {
        // 동기화되지 않은 코드
        synchronized(this) {
            this.count += value; // 이 부분만 동기화
        }
        // 동기화되지 않은 코드
    }
    ```
- static 메서드 내부 블록:
  - 동기화가 필요한 static 메서드 내부의 특정 코드만 블록으로 지정해 클래스 객체를 기준으로 동기화한다.
  - 특정 블록에 대해 클래스의 모든 스레드의 동기화를 보장한다.
  - 사용 시 주의: 클래스의 다른 스태틱 메소드와 동시 실행을 방지할 수 있다.
  - 예시:
    ```java
    public static void add(int value) {
        synchronized (MyClass.class) {
            count += value; // 이 부분만 동기화
        }
    }
    ```

</details>

<details>
  <summary>효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?</summary>

- 장점
  - 직관적이고 사용법이 간단하다. 쉽게 스레드 안전성을 확보할 수 있다.
  - JVM 레벨에서 지원하므로 안정성이 높다.
- 단점
  - 무조건 블로킹 기반이라 성능 저하 및 효율성 문제가 발생할 수 있다.
  - 특히, BLOCKED 상태의 스레드는 락이 풀릴 때까지 무한 대기를 하며 synchronized는 인터럽트, 타임아웃을 지원하지 않는다.
  - 경쟁이 많으면 context switching 비용이 크다.
  - 전체 메서드에 걸면 임계영역이 넓어져 병렬성이 떨어진다. 따라서, 공유 객체를 사용하는 임계 영역(critical section)은 꼭 필요한 부분에만 최대한 작게 유지하는 것이 중요하다.
  </details>

<details>
  <summary>Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.</summary>

- `ReentrantLock` (재진입 가능 락)
  - synchronized와 동일하게 한 번에 하나의 스레드만 접근 가능하지만, 더 세밀한 제어 가능
  - 락의 획득과 해제를 명시적으로 관리 (개발자가 직접 관리)
  - 공정성 설정 가능, 타임아웃, 인터럽트 처리 가능.
  - 락 해제(unlock())을 직접 호출해야 하기 때문에 잘못 쓰면 데드락 발생 가능
- `ReadWriteLock`
  - 읽기와 쓰기를 구분하여 동기화 적용
  - 다수의 스레드가 동시에 읽기 가능
  - 쓰기 작업 시에만 쓰기 락 적용
  - 읽기 작업이 많은 경우 성능 최적화 가능
- `Semaphore`
  - 일정 개수의 스레드만 공유 자원에 접근하도록 제어 (동시 접근 허용)
  - 특정 리소스에 접근 가능한 최대 스레드 수 제한
  - 리소스 개수 기반 제어 가능 (동시성 수준 제한).
- `Atomic 클래스들 (AtomicInteger, AtomicLong 등)`
  - CAS (Compare-And-Swap) 기반으로 락 없이 원자적 연산 제공.
  - 동기화 없이 안전한 연산 수행 가능
  - 내부적으로는 JVM이 CPU의 CAS 명령어를 활용 → 매우 빠름, 성능 우수
  </details>

<details>
  <summary>Thread Local에 대해 설명해 주세요.</summary>

- 정의: 스레드마다 독립적인 변수를 제공하는 메커니즘.
- 동기화 자체를 없애고 “스레드마다 고유 상태를 부여”하는 관점에서 등장한 개념으로, 스레드별 독립된 복사본을 유지하기 위해 만들어진 도구.
- 같은 코드를 여러 스레드가 실행해도 각 스레드가 가진 ThreadLocal 변수 값은 서로 다름.
- ThreadLocal은 자바 스레드 Stack이 아닌 Heap 영역에 생성된 Thread 객체 내부의 필드(ThreadLocalMap)에 저장된다.
- 특징
  - 공유 자원에 대한 동기화 필요 없음 (스레드 고유 데이터이므로).
  - 보통 사용자 세션, 트랜잭션 컨텍스트, 로깅 traceId 등에 활용됨.
  - 스레드 격리 및 설계 단순화 가능.
  </details>

## 8. Java Stream에 대해 설명해 주세요.

<details>
  <summary>Java Stream이란?</summary>

- Java Stream: Java 8에서 도입된 데이터 처리 API로, 데이터 소스를 추상화하여 함수형 스타일로 데이터를 처리할 수 있도록 한다.
- for문 중첩 대신 filter, map, collect 같은 파이프라인 방식으로 작성해 코드가 간결해진다.
- Java Stream의 특징
  - 파이프 라이닝: 중간 연산들이 Stream을 반환하며 연결되고, 최종 연산이 호출될 때 한 번에 실행되는 구조를 가진다. 이로 인해 layziness(게으름), short-circuiting(쇼트서킷) 같은 최적화를 얻을 수 있다.
    - layziness: 최종 연산이 오기 전까지 아무것도 실행 안 함.
    - short-circuiting: findFirst() 같은 최종 연산을 쓰면, 첫 번째 요소만 찾으면 나머지는 아예 안 돌고 멈춘다.
  - 내부 반복: 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.
  - 일회용: Iterator처럼 일회용이며, 한 번 사용하면 다시 사용할 수 없다.

</details>

<details>
  <summary>Stream과 for ~ loop의 성능 차이를 비교해 주세요.</summary>

- **for loop**
  - 전통적인 외부 반복(External Iteration).
  - JVM이 최적화하기 쉽고, 불필요한 객체 생성이 없어 오버헤드가 거의 없다.
  - 일반적으로 소량 데이터 처리나 단순 연산에서는 for문이 더 빠르다.
- **Strteam**
  - 내부 반복(Internal Iteration)을 사용.
  - 람다 캡처, 함수형 인터페이스 객체 생성 등으로 인한 추가 오버헤드가 존재한다.
  - 가독성, 유지보수성이 뛰어나고, filter, map, reduce 같은 고수준 연산을 선언적으로 조합 가능
  - 대량 데이터에서 병렬 처리(parallelStream)를 활용하면 성능상 이점이 있을 수 있다.
- Primitive Type: 성능 최우선 → for-loop 권장.
- Wrapped Type: Stream과 for-loop의 성능 차이가 거의 없음 → 가독성과 유지보수성이 좋은 Stream을 써도 무방. (wrapper type은 Collection을 순회하는 비용이 크기 때문에 for-loop와 stream 간의 성능 차이가 거의 나지 않음)
</details>

<details>
  <summary>Stream은 병렬처리 할 수 있나요?</summary>

- 병렬 스트림(parallelStream)이란: Java 8에서 도입된 Stream의 기능 중 하나로, 각 스레드에서 처리할 수 있도록 스트림 요소를 여러 Chunk로 분할한 것이다.
- 내부적으로 ForkJoinPool (공용 스레드풀)을 이용하여 데이터를 병렬 처리한다.
  - Fork / Join Framework: Java 7에서 도입된 병렬 처리 프레임워크로, 큰 작업을 더 작은 작업으로 분할(Fork)하고, 병렬 처리한 후 병합(Join)하는 방식으로 동작한다.
- 단점
  - 스레드 관리 오버헤드가 있어서 소량 데이터는 오히려 속도 저하가 발생할 수 있다.
  - 공유 자원 접근이 필요하면 동기화 비용이 발생한다.
  </details>

<details>
  <summary>Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.</summary>

- `map(Function<T, R>)`:
  - 요소를 변환
  - 예시) .map(String::length)
- `filter(Predicate<T>)`:
  - 조건을 만족하는 요소만 통과
  - 예시) .filter(n -> n % 2 == 0)
- `sorted(Comparator<T>)`
  - 요소 정렬
  - 예시) .sorted(Comparator.comparing(String::length))
- `forEach(Consumer<T>)`
  - 요소 소비(출력, 저장 등)
  - 예시) .forEach(System.out::println)
- `reduce(BinaryOperator<T>)`
  - 누적 연산(합계, 곱 등)
  - 예시) .reduce(0, Integer::sum)
- `collect(Supplier<R>, BiㅇConsumer<R, ? super T>, BiConsumer<R,R>)`
  - Stream → 컬렉션/맵 등으로 수집
  - 예시) .collect(Collectors.toList());

</details>

<details>
  <summary>가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?</summary>

- 람다식/익명 클래스 안에서 사용하는 외부 변수는 final 또는 effectively final(사실상 final) 이어야 한다.
- 스트림은 기본적으로 병렬처리 지원, 함수형 인터페이스를 활용하기 때문에 멀티스레드 환경에서 외부 변수의 일관성 문제가 발생하지 않기 위해서 final 또는 변경되지 않는 변수만 허용한다.

</details>

### 9. Java의 GC에 대해 설명해 주세요.

<details>
  <summary>Java의 GC란?</summary>

- Java의 GC(Garbaege Collection)이란, 더 이상 참조되지 않는 객체를 메모리에서 해제하는 JVM의 메모리 관리 기법.
- 메모리 누수 위험을 줄일 수 있음.
- GC의 동작 과정:
  1. Mark 단계: GC는 루트 객체에서 시자해서 참고 그래프를 따라가며 살아있는 객체를 모두 마킹.
  2. Sweep 단계: 힙 메모리를 순회하면서 마킹되지 않는 객체를 가비지로 간주,
  3. Compact 단계 (필요 시): 단편화 문제를 해결하기 위해 객체 정리 진행
  </details>

<details>
  <summary>finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?</summary>

- finalize()란, GC가 객체를 회수하기 직전에 JVM이 한 번 호출해 주는 콜백 메서드.
- 사용 시 문제점:
  - 비결정성: finalize()가 언제 호출되는지를 예측할 수 없음.
  - 객체를 수거할 때마다 finalize() 큐에 넣고 실행해야 함. 가비지 컬렉션의 성능 저하 발생.
  - finalize()에서 예외가 발생하면 이 예외는 무시되며, 남은 정리 코드는 실행되지 않음. 이로 인해 자원이 제대로 회수되지 않는 누수가 발생.
- 성능/안정성 문제로 Java 9부터 finalize()는 Deprecated됨.
- 대체 수단: try-with-resources나 Cleaner 사용
</details>

<details>
  <summary>어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?</summary>

- 단순히 변수를 null로 설정했다고 해서 무조건 GC 대상이 되는 것은 아님.
- null을 할당한 것은 하나의 참조를 끊은 것일 뿐이고, 모든 참조가 사라져야 GC의 대상이 된다.
- GC는 "null 여부"가 아니라 "도달 가능성(reachability)"에 의해 대상 객체를 판별한다.
  - GC의 reachability: 어떤 객체에 아직 유효한 참조가 있으면 'reachable'로, 없으면 'unreachable'로 구별하고, unreachable 객체를 garbage로 간주해 GC를 수행
  </details>

### 10. equals()와 hashcode()에 대해 설명해 주세요.

<details>
  <summary>equals()와 hashcode()</summary>

- **equals()**

  - 기본적으로 2개의 객체가 동일한지 논리적으로 검사하기 위해 사용한다.
  - 2개의 객체가 가리키는 곳이 동일한 메모리 주소일 경우에만 동일한 객체가 된다.

- **hashcode()**

  - 두 객체가 같은 객체인지를 비교한다.
  - 실행 중에(Runtime) 객체를 대표하는 정수값(해시 값)을 반환한다. 일반적으로 Heap에 저장된 객체의 메모리 주소를 반환한다.
  - HashMap, HashSet 같은 해시 기반 컬렉션에서 객체를 효율적으로 찾는 데 사용.

- **equals()와 hashcode()** - equals가 true라면 hashCode도 반드시 동일해야 한다. - equals가 false일 때는 hashCode가 같을 수도, 다를 수도 있다. - equals 구현에 사용된 필드가 변하지 않았다면 hashCode도 실행 중 일관되게 유지되어야 한다.
</details>

<details>
  <summary>본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?</summary>
  
  - equals를 재정의할 때 hashcode도 함께 재정의한다.
    - hashcode를 재정의하지 않으면 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제가 발생할 수 있다.
    - equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
  - [hashCode 재정의 가이드](https://www.baeldung.com/java-hashcode)
  - [참고 블로그](https://tecoble.techcourse.co.kr/post/2020-07-29-equals-and-hashCode/)
</details>

<details>
  <summary>그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.</summary>

- equals와의 일관성: equals가 true인 두 객체는 hashCode도 반드시 같아야 하고, equals가 false여도 hashCode는 같을 수 있음.
- 일관된 값 반환: 객체 상태가 변하지 않는 한, 실행 중 언제 호출해도 같은 hashCode가 반환돼야 함.
- 성능 고려: 해시 기반 컬렉션(HashSet, HashMap 등)은 hashCode가 골고루 분포될수록 성능이 좋아짐. Objects.hash(...)는 간단하지만 느릴 수 있고, 성능 민감한 경우는 직접 구현 권장.
</details>

### 11. IoC와 DI에 대해 설명해 주세요.

<details>
  <summary>IoC와 DI에 대해 설명해 주세요.</summary>

- **제어의 역전(IoC)**

  - 제어(Control): 어떠한 클래스 내부에서 다른 객체를 생성하고 이용할 때, 직접 코드를 생성하여 '제어'한다고 한다.
  - 역전(Inversion): 객체를 클래스 내부에서 직접 생성하고 제어하는 것이 아니라, 외부에서부터 인자로 받아 초기화 하는 것
  - 제어의 역전(IoC): 객체의 생성 및 생명주기 관리, 의존성 연결을 개발자가 아닌 컨테이너(Spring)가 담당하는 것. 객체에 대한 제어권이 프레임워크에 있음.
  - IoC가 필요한 이유:
    - 객체를 직접 만들면 코드가 특정 구현체에 강하게 결합된다.
    - IoC를 적용하면 역할과 책임이 분리되고, 결합도가 낮아져 확장성, 유지보수성, 테스트 용이성이 증가한다.

- **의존성 주입(DI)** - IoC를 구현하는 대표적인 방법. - 객체가 사용할 의존 객체를 스스로 생성하지 않고, 외부(Spring 컨테이너)에서 주입받음. - DI vs DL (Dependency Lookup) - DI: 컨테이너가 객체에 필요한 의존성을 주입해줌. - DL: 객체가 필요할 때 컨테이너에 직접 조회(Lookup)해서 가져옴. - 의존성 주입 방법 - 생성자 주입: 객체의 불변성 확보, 순환 참조 에러 방지 등 다양한 이점을 가짐. - 필드 주입 (@Autowired): 스프링 프레임워크에 의존적이므로 권장되지 않음. - 세터 주입: 선택적 의존성에 유용하지만, 불변성을 깨트릴 수 있음.
</details>

<details>
  <summary>후보 없이 특정 기능을 하는 클래스가 딱 한 개라면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?</summary>

- 구체 클래스를 그냥 사용해도 문제는 없지만, Spring Bean을 사용하는 건 여러 장점을 가진다.
- Spring Bean은 Spring IoC 컨테이너에 의해 관리되는 객체를 의미한다. IoC 컨테이너에 의해 생성, 초기화, 소멸된다.
- Spring Bean의 특징
  - 싱글톤 스코프: 기본값으로, 특별히 지정하지 않으면 자동으로 싱글톤 Bean으로 등록된다.
  - 다양한 스코프: prototype, request, session 등 웹 환경에 맞춘 다양한 스코프 제공한다.
  - 의존성 주입(DI): 다른 Bean과의 의존 관계를 외부에서 주입받아 사용한다.
  - 라이프사이클 관리: 컨테이너가 Bean의 생성·초기화·소멸 과정을 관리한다. 개발자가 직접 객체 생명주기를 제어할 필요가 없다.
- Spring Bean의 장점 - 의존성 관리 용이: 객체 간 결합도를 낮추고 유연한 확장이 가능하다. - 싱글톤으로 관리: 메모리 절약 및 성능 최적화. - 객체 생명주기를 컨테이너가 책임져서 리소스 관리 효율적 - 테스트 시 Mock 객체로 쉽게 교체 가능
</details>

<details>
  <summary>Spring의 Bean 생성 주기에 대해 설명해 주세요.</summary>
  
1. 스프링 컨테이너 생성
    - ApplicationContext 같은 IoC 컨테이너가 먼저 생성된다.
2. 스프링 빈 생성
    - 컨테이너가 설정 정보를 읽고 new 키워드를 사용해 Bean 객체를 생성한다.
3. 의존관계 주입 (DI)
    - 생성된 Bean에 필요한 의존 객체들을 주입한다.
    - 생성자 주입, 세터 주입, 필드 주입 등이 이 단계에서 수행된다.
4. 초기화 콜백
    - Bean이 완전히 생성되고 의존관계가 주입된 뒤 실행되는 단계다.
    - @PostConstruct, InitializingBean.afterPropertiesSet() 같은 초기화 메서드가 실행된다.
    - 추가적인 설정이나 리소스 초기화 로직을 넣을 수 있다.
5. 사용
    - 애플리케이션 로직에서 Bean을 실제로 사용한다.
6. 소멸 전 콜백
    - 컨테이너가 내려가기 직전에 Bean의 종료 메서드가 호출된다.
7. @PreDestroy, DisposableBean.destroy() 등이 실행된다.
    - DB 연결 해제, 네트워크 소켓 종료, 파일 닫기 같은 자원 해제 작업을 수행한다.
8. 스프링 종료
    - 컨테이너가 종료되면서 모든 Bean이 소멸된다.
</details>

<details>
  <summary>프로토타입 빈은 무엇인가요?</summary>

- 프로토타입 빈: 스프링에서 기본 빈 스코프는 싱글톤(singleton)이지만, 프로토타입(prototype) 스코프로 설정하면, 빈을 요청할 때마다 새로운 객체가 생성된다.
- 빈의 스코프란: 빈 오브젝트가 만들어져 존재할 수 있는 범위.
- 프로토타입 빈의 특징: - 요청 시마다 항상 새로운 인스턴스 반환 - 스프링 컨테이너는 객체 생성과 의존성 주입까지만 관리 (초기화 콜백까지만 실행, 소멸 콜백은 호출되지 않음) - 상태를 가지는 빈을 매번 새로 생성해서 사용해야 할 때 적합
</details>

<details>
  <summary><h3>12. AOP에 대해 설명해 주세요.</h3></summary>
<ul>
<li> @Aspect는 어떻게 동작하나요?</li>
</ul>
</details>

<details>
  <summary><h3>13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?</li>
</ul>
</details>

<details>
  <summary><h3>14. DispatcherServlet 의 역할에 대해 설명해 주세요.</h3></summary>
<ul>
<li>여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?</li>
<li>수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?</li>
</ul>
</details>

<details>
  <summary><h3>15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?</h3></summary>
<ul>
<li> 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?</li>
<li> N + 1 문제에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>16. @Transactional 은 어떤 기능을 하나요?</h3></summary>
<ul>
<li> @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?</li>
<li> 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?</li>
</ul>
</details>

<details>
  <summary><h3>17. Java 에서 Annotation 은 어떤 기능을 하나요?</h3></summary>
<ul>
<li> 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?</li>
<li> Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?</li>
</ul>
</details>

<details>
  <summary><h3>18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?</h3></summary>
<ul>
<li> 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?</li>
</ul>
</details>
