## Java, Spring

# 1. JVM

<details>
<summary>JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.</summary>

- JVM은 자바 바이트코드를 실행해주는 가상 머신으로, 자바 프로그램의 런타임 환경을 제공하는 역할을 합니다. 작성된 자바 코드는 컴파일되면 `.class`라는 바이트코드로 변환되고, 이 바이트코드를 실제 머신 코드로 변환해서 실행해주는 것이 JVM입니다.

- 이 과정을 통해 자바는 플랫폼 독립성을 가지게 되고, Write Once, Run Anywhere를 실현할 수 있습니다. (한 번만 작성하면 어디서든 실행 가능!)

![img_jyj.png](img%2Fimg_jyj.png)

</details>

<details>
<summary>그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?</summary>

- 가능합니다. JVM은 바이트코드를 실행하는 범용 실행 환경이기 때문에, Kotlin, Groovy, Scala 같은 언어들도 JVM 위에서 실행될 수 있습니다.

</details>

<details>
<summary>반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?</summary>

- 기본적으로는 JVM 언어는 JVM 바이트코드를 생성하도록 설계되어 있어서, 일반적인 네이티브 바이너리로 바로 컴파일해서 실행하는 건 어렵습니다.

- 하지만 예외적으로 GraalVM이나 Kotlin/Native와 같은 도구를 사용하면 JVM 언어도 네이티브 바이너리로 컴파일이 가능합니다. 코드를 JVM 없이 실행할 수 있도록 모든 기능을 컴파일 타임에 고정해서 미리 만들어 줍니다.

- 다만 이 경우 JVM의 GC, 런타임 최적화 같은 이점은 포기해야 합니다. JVM의 주요 이점은 "런타임 환경"에서 제공하는 것이고, GC(가비지 컬렉션)는 더 이상 사용되지 않는 메모리를 자동으로 회수하는 기능이며, JIT 컴파일 최적화도 있습니다.

</details>
ㄴ
<details>
<summary>VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</summary>

- 장점은 플랫폼 독립성과 안정성, 런타임 최적화입니다. JVM만 있다면 어떤 운영체제에서도 자바 코드를 실행할 수 있고, 런타임 중 JIT 컴파일러를 통해 코드가 최적화되기도 합니다. 또한 JVM이 예외 처리나 메모리 관리(GC)를 담당하므로 개발자는 비즈니스 로직에 집중할 수 있습니다.

- 단점은 성능과 자원 사용 측면입니다. VM 위에서 동작하다 보니 네이티브 코드보다는 실행 속도가 느리고, JVM 자체도 메모리와 CPU 자원을 별도로 사용하기 때문에 무거운 환경에서는 부담이 될 수 있습니다.

</details>

<details>
<summary>JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?</summary>

- 아니요, 일반적으로는 부모-자식 프로세스 관계가 아닙니다.

- 실제 관계는 JVM이 하나의 프로세스로 실행되고, Java 애플리케이션은 JVM 내부의 스레드로 실행되는 단일 프로세스 - 스레드 관계입니다.

- 예외 상황으로는 ProcessBuilder를 사용하여 외부 프로세스를 실행하는 경우에만 JVM이 부모 프로세스가 됩니다. 장점은 스레드가 자원 공유를 통해 효율적으로 통신하고 작업 처리할 수 있다는 점입니다.

</details>

# 2. final 키워드

<details>
<summary>final 키워드를 사용하면, 어떤 이점이 있나요?</summary>

- final 키워드는 불변성을 보장하기 때문에 코드 안정성이 증가합니다. 특히 안전한 공유 객체가 되어 멀티스레드 환경에서 동기화 문제를 줄일 수 있습니다.

> ### final은 불변을 보장할까?
> 1.  final은 재할당을 막는 키워드일 뿐이다. 
> 2. 기본 타입(primitive)은 값 자체가 바뀌지 않아 사실상 불변처럼 동작한다.
> 3. 참조 타입(객체, 컬렉션)은 내부 상태 변경은 막지 못하므로 불변을 보장하지 않는다.
> ```java
> // 기본 타입 - 불변
> final int age = 25;
> age = 30; // 컴파일 에러. 값 변경 불가
> 
> // 객체 - 내부 상태 변경 가능
> final Person person = new Person("김철수");
> person.setName("김영희"); // 내부 상태는 변경됨
> 
> // 컬렉션 - 요소 추가/삭제 가능
> final List<String> names = new ArrayList<>();
> names.add("김철수"); // 리스트에 요소 추가됨
> ```

</details>

<details>
<summary>그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?</summary>

- 네, final 키워드는 컴파일 과정에서 특별하게 취급됩니다. final이 붙은 기본형 상수나 문자열 상수는 컴파일 시점에 값이 코드에 직접 삽입됩니다. 이런 것을 compile-time constant라고 부르며, JVM은 해당 클래스를 로딩하지 않고도 값을 사용할 수 있습니다.

</details>

# 3. 인터페이스와 추상 클래스

<details>
<summary>인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.</summary>

- 인터페이스와 추상 클래스 모두 다형성을 제공하지만, 목적과 구조가 다릅니다.

- 추상 클래스는 상속받을 클래스들이 공통으로 가지는 메서드와 필드가 많아 중복 멤버 통합이 필요할 때 사용합니다. extends 키워드를 사용하고 단일 상속만 가능하며, 공통 기능을 제공하여 재사용성을 향상시킵니다.

- 인터페이스는 애플리케이션의 기능을 정의해야 하지만 그 구현 방식이나 대상에 대해 추상화할 때 사용합니다. implements 키워드를 사용하고 다중 구현이 가능하며, 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장합니다.

</details>

<details>
<summary>왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?</summary>

- 클래스 단일 상속 제한 이유는 다이아몬드 문제 때문입니다. 두 개 이상의 클래스에서 상속받을 때 같은 메서드가 구현되어 있을 경우, 자식 클래스에 어떤 메서드를 상속받아야 하는지 모호해지는 문제가 발생할 수 있고, 상속 구조가 복잡해져 유지보수가 어려워집니다.

- 인터페이스 다중 구현이 가능한 이유는 메서드 구현을 강제하지만, 메서드의 구현은 자식 클래스가 담당하기 때문입니다. 메서드 충돌 시 오버라이딩을 통해 충돌을 해결할 수 있고, "동일한 실행"을 보장하기 위한 계약이므로 다중 구현이 자연스럽습니다.

</details>

# 4. 리플렉션

<details>
<summary>리플렉션에 대해 설명해 주세요.</summary>

- 리플렉션(Reflection)은 실행 시간(런타임)에 클래스, 메서드, 필드 등의 정보를 동적으로 조회하고 조작할 수 있는 기능입니다. 특히 스프링 프레임워크에서는 리플렉션을 사용해서 많은 핵심 기능들을 구현합니다. 의존성 주입 등이 대표적인 예시입니다.

</details>

<details>
<summary>의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?</summary>

- 네, 리플렉션을 사용하면 기본적으로 접근할 수 없는 private 필드나 메서드에 접근하고 이를 수정할 수 있습니다. 클래스 설계자가 의도한 방식이 아니기 때문에 보안에 취약점이 발생할 수 있습니다.

- 또한 리플렉션을 사용하여 특정 부분을 동적으로 변경해 악성 코드를 삽입하거나 실행할 수 있습니다. 이를 방지하기 위해 보안관리자를 활성화하여 리플렉션을 사용할 수 있는 코드와 사용할 수 없는 코드를 구분하거나, setAccessible(false)로 하여 꼭 필요한 경우에만 공개합니다.

</details>

<details>
<summary>리플렉션을 언제 활용할 수 있을까요?</summary>

- 리플렉션은 주로 프레임워크와 라이브러리 개발에서 많이 사용됩니다. 스프링 프레임워크의 경우 의존성 주입(DI)이나 AOP 프록시 생성 시 클래스 정보를 동적으로 분석하여 빈을 생성하고 주입하는 데 활용합니다.
    - 스프링에서 리플렉션 동작 과정을 자세히 보면, 먼저 @Component나 @Service 같은 어노테이션이 붙은 클래스를 스캔할 때 리플렉션을 사용하여 해당 클래스의 메타데이터를 읽어옵니다. 그 다음 @Autowired나 @Resource 같은 의존성 주입 시에는 리플렉션으로 필드나 생성자의 타입 정보를 분석하여 적절한 빈을 찾아서 주입합니다.
    - AOP의 경우 @Transactional 같은 어노테션이 붙은 메서드를 찾기 위해 리플렉션으로 메서드 정보를 분석하고, 프록시 객체를 생성할 때도 원본 메서드의 시그니처를 리플렉션으로 파악하여 메서드 호출을 가로채는 구조를 만듭니다.

- 또한 JUnit과 같은 테스트 프레임워크에서는 테스트 클래스의 메서드를 동적으로 찾아서 실행하거나, Mockito 같은 모킹 라이브러리에서는 프록시 객체를 생성할 때 리플렉션을 사용합니다.

</details>

# 5. static

<details>
<summary>static class와 static method를 비교해 주세요.</summary>

- static class는 주로 내부 클래스에서 사용되며, 외부 클래스의 인스턴스 없이 독립적으로 동작할 수 있도록 합니다. 외부 참조 문제를 해결하여 외부 인스턴스 참조로 인한 메모리 누수 현상을 방지하고, 클래스 정의를 위한 것입니다.

- static method는 특정 객체가 아닌 클래스 자체에서 호출할 수 있는 메서드로, 주로 유틸리티 함수나 공통 기능을 구현하는 데 사용됩니다. 특정 동작을 수행하는 것이고, 두 개 모두 인스턴스 없이 호출 가능하다는 공통점이 있습니다.

</details>

<details>
<summary>static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?</summary>

- 이점으로는 메모리 최적화가 있습니다. 객체를 생성하지 않고도 멤버에 접근할 수 있어 성능 향상의 이점이 있고, 고정된 영역만 사용하여 메모리 낭비를 방지할 수 있습니다.

- 제약으로는 메모리 누수 가능성이 있습니다. static으로 선언된 멤버는 JVM의 heap 영역이 아닌 method area에 저장되고 GC의 대상이 아니므로 메모리 누수가 발생할 수 있습니다. 또한 객체지향 원칙을 위반하고, 프로그램 종료 시까지 메모리가 할당되어 남발 시 메모리와 프로그램 성능이 저하될 수 있습니다.

</details>

<details>
<summary>컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.</summary>

- 컴파일 단계에서 .class 파일에 static 멤버가 존재하면, 객체 생성 없이도 접근 가능하도록 바이트 코드가 생성됩니다. JVM이 실행될 때는 Method Area에 static 멤버가 저장되고 런타임 시에 static 멤버는 객체 생성과 관계없이 접근이 가능합니다. 메모리 할당은 객체가 heap 영역 메모리에 올라가기 전에 호출해서 사용할 수 있습니다.

</details>

# 6. Exception

<details>
<summary>Java의 Exception에 대해 설명해 주세요.</summary>

- Exception은 프로그램 실행 중에 발생할 수 있는 오류 상황을 처리하기 위한 Java의 메커니즘입니다. 예외의 정의는 사용자의 조작이나 개발자의 코딩 실수 등으로 발생하는 오류이고, 예외 처리의 목적은 프로그램이 비정상적으로 종료되는 것을 방지하고, 오류 상황에 대한 적절한 대응을 하는 것입니다.

</details>

<details>
<summary>예외처리를 하는 세 방법에 대해 설명해 주세요.</summary>

- 첫 번째는 예외 복구입니다. 예외 상황을 파악하고 문제를 해결해서 정상 상태로 되돌려놓는 방법으로, 예외가 발생하더라도 일정 수만큼 재시도하여 예외 복구를 시도합니다.

- 두 번째는 예외 처리 회피입니다. 예외 처리를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 방법으로, 호출한 쪽에서 예외를 처리하는 것이 바람직할 때 사용합니다.

- 세 번째는 예외 전환입니다. 회피 방법과 비슷하게 메서드 밖으로 예외를 던지지만, 더 명확한 의미를 가진 예외로 변경해서 예외를 던지는 방법입니다.

</details>

<details>
<summary>CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.</summary>

- CheckedException은 개발자가 반드시 예외처리해야 하는 오류입니다. 미처리 시 컴파일 에러가 발생하고, 복구 가능성이 있는 예외로 IOException, SQLException 등이 대표적입니다.

- UncheckedException은 예외처리를 하지 않아도 컴파일 에러가 발생하지 않습니다. RuntimeException 클래스를 상속받는 예외들로, 복구 가능성이 없는 예외로 NullPointerException, ArrayIndexOutOfBoundsException 등이 대표적입니다. 예상치 못한 상황에서 발생하는 것이 아니므로 굳이 예외 처리를 강제하지 않습니다.

</details>

<details>
<summary>예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?</summary>

- 네, 예외처리가 성능에 영향을 미칠 수 있습니다. 성능 영향 요인으로는 스택 트레이스 캡처가 있습니다. JVM이 exception handler가 포함된 메서드를 찾기 위해 call stack을 검색하는 비용이 발생하고, 예외 객체 생성으로 인한 오버헤드가 있습니다.

- 부하를 줄이는 방법으로는 입력 값을 사전에 검증하여 예외 발생을 최소화하고, 예외 객체를 캐싱하여 재사용하며, 예외를 정상적인 제어 흐름으로 사용하지 않는 것입니다. 또한 커스텀 예외에서 fillInStackTrace를 오버라이드하여 스택 트레이스 생성 비용을 줄일 수 있습니다.

</details>

# 7. Synchronized

<details>
<summary>Synchronized 키워드에 대해 설명해 주세요.</summary>

- Synchronized 키워드는 자바에서 멀티스레드 환경에서 동기화를 보장하기 위해 사용하는 키워드입니다. 동작 원리는 공유자원에 여러 스레드가 동시에 접근하지 못하도록 락을 걸어 데이터 일관성을 유지하는 것입니다. 임계 영역(Critical Section)은 공유데이터가 사용되는 부분을 의미하며, 자바에서는 이 부분에 synchronized 키워드를 사용합니다.

</details>

<details>
<summary>Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.</summary>

- synchronized method는 인스턴스 단위로 lock을 걸지만, synchronized 키워드가 붙은 메소드들에 대해서만 lock을 공유합니다. synchronized 메소드를 호출하는 순간, 모든 synchronized 메소드에 lock이 걸려 다른 스레드가 어떠한 synchronized 메소드를 호출할 수 없습니다.

- static synchronized method는 인스턴스가 아닌 클래스 단위로 lock을 공유합니다. 인스턴스 단위에 거는 lock은 공유되지 않아 동기화 이슈가 발생할 수 있습니다.

- synchronized block은 synchronized 인자 값으로 this를 사용하면 block을 통해 만들어진 스레드는 lock을 공유하고, static이 추가되면 클래스 단위로 lock을 공유합니다.

</details>

<details>
<summary>효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?</summary>

- 멀티스레드 환경에서 데이터 정합성을 유지해야 하는 상황이라면 좋은 키워드입니다. 하지만 주의사항이 있습니다. 락을 획득하고 해제하는 과정에서 성능 저하가 발생하고, 경합 상태에서 병목이 심해지는 경향이 있으며, 단순한 읽기 작업에서도 불필요한 lock이 적용되면 속도 저하가 발생합니다. 또한 스레드 대기와 데드락의 위험성이 존재합니다. 결론적으로 상황에 맞게 사용해야 하며, 과도한 동기화는 성능 저하를 일으킬 수 있습니다.

</details>

<details>
<summary>Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.</summary>

- **Concurrent Collections**: 멀티스레드 환경에서 안전한 컬렉션 관리, 읽기와 쓰기 병행 작업이 많을 때 synchronized보다 효율적

- **ReentrantLock**: synchronized와 동일하게 한 번에 하나의 스레드만 접근 가능하지만, 더 세밀한 제어 가능
  - 락의 획득과 해제를 명시적으로 관리 (개발자가 직접 관리)
  - 공정성 설정, 타임아웃, 인터럽트 처리 가능
  - 락 해제(unlock())을 직접 호출해야 하기 때문에 잘못 쓰면 데드락 발생 가능

- **ReadWriteLock**: 읽기와 쓰기를 구분하여 동기화 적용
  - 다수의 스레드가 동시에 읽기 가능
  - 쓰기 작업 시에만 쓰기 락 적용
  - 읽기 작업이 많은 경우 성능 최적화 가능

- **Semaphore**: 일정 개수의 스레드만 공유 자원에 접근하도록 제어
  - 동시 접근 허용 개수 제한
  - 특정 리소스에 접근 가능한 최대 스레드 수 제한
  - 리소스 개수 기반 제어 가능 (동시성 수준 제한)

- **Atomic 클래스들** (AtomicInteger, AtomicLong 등): CAS(Compare-And-Swap) 기반으로 락 없이 원자적 연산 제공
  - 동기화 없이 안전한 연산 수행 가능
  - 내부적으로 JVM이 CPU의 CAS 명령어를 활용 → 매우 빠름, 성능 우수

- **CompletableFuture**: 비동기 프로그래밍을 통한 동시성 처리 제공

</details>

<details>
<summary>Thread Local에 대해 설명해 주세요.</summary>

- ThreadLocal은 Java에서 지원하는 Thread Safe한 기술로, 멀티 스레드 환경에서 각각의 스레드가 개별적으로 데이터를 저장하고 관리할 수 있도록 도와줍니다. 핵심 특징으로는 각 스레드가 별도의 저장공간을 할당받아 각 상태를 가질 수 있고, 멀티스레드 환경에서도 데이터 충돌 없이 안전하게 사용할 수 있습니다.

- 주의사항으로는 WAS 환경에서 Thread pool 기반으로 동작하므로 ThreadLocal 사용 후 비워주지 않으면 다른 사용자가 기존에 세팅된 ThreadLocal의 데이터를 공유할 수 있습니다. 메모리 누수 방지를 위해 Thread의 사용이 끝나는 시점에 ThreadLocal을 초기화할 필요가 있습니다. 사용처로는 Spring Security 내 context 보관 등이 있습니다.

</details>

# 8. Stream

<details>
<summary>Java Stream에 대해 설명해 주세요.</summary>

- Stream은 데이터 처리 파이프라인을 위한 API입니다. 

- 실제 개발에서 자주 사용하는 방식:
  - 컬렉션 데이터를 필터링할 때: filter()로 조건에 맞는 데이터만 추출
  - 데이터 변환할 때: map()으로 객체를 다른 형태로 변환
  - 데이터를 수집할 때: collect()로 결과를 리스트나 맵으로 모음
  - 데이터 개수나 합계를 구할 때: count(), sum() 등으로 집계

- Stream의 장점은 함수형 프로그래밍 스타일을 지원한다는 점이고, 지연 평가로 실제로 결과가 필요할 때까지 처리를 미룰 수 있습니다. 또한 원본 데이터를 건드리지 않아서 안전하게 사용할 수 있습니다.

</details>

<details>
<summary>Stream과 for ~ loop의 성능 차이를 비교해 주세요</summary>

- 일반적으로 Stream이 for loop보다 더 느립니다. 성능 차이 이유로는 for loop는 개념이 오래되어 JVM 내부에서 최적화가 잘 되어 있지만, Stream은 함수형 프로그래밍 특징인 불변성을 위해 복사를 해 메모리 증가, 오버헤드 등으로 속도가 느립니다.

- 단순한 반복 작업은 for loop가 유리하지만, 복잡한 데이터 처리나 가독성이 중요한 경우는 Stream이 유리합니다.

</details>

<details>
<summary>Stream은 병렬처리 할 수 있나요?</summary>

- 네, 병렬처리를 할 수 있습니다. 병렬처리 방법으로는 parallel() 메서드로 기존 Stream에 병렬 처리를 적용하거나, parallelStream()으로 병렬 처리가 적용된 Stream을 생성할 수 있습니다.

- 내부 동작은 Fork와 Join Framework를 사용하여 병렬 처리를 진행하고, 장점은 개발자가 직접 스레드나 스레드 풀을 생성 및 관리하지 않고 메서드로 간단하게 병렬처리를 진행할 수 있다는 점입니다. 주의사항은 모든 상황에서 병렬 처리가 유리하지는 않으며, 데이터 크기와 연산 복잡도를 고려해야 합니다.

</details>

<details>
<summary>Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.</summary>

- 총 4가지의 주요 함수형 인터페이스가 있습니다. 

- Predicate<T>는 주어진 입력을 받아 true 또는 false를 반환하는 인터페이스로 filter() 메서드에서 주로 사용합니다.

- Function<T, R>은 입력을 받아 다른 타입의 출력을 반환하는 함수형 인터페이스로 map() 메서드에서 주로 사용합니다.

- Supplier<T>는 매개변수 없이 값을 반환해주는 인터페이스로 generate() 메서드에서 주로 사용합니다.

- Consumer<T>는 입력을 받아 처리하지만 반환값이 없는 인터페이스로 forEach() 메서드에서 주로 사용합니다.

</details>

<details>
<summary>가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?</summary>

- 람다나 익명 클래스에서 외부 변수를 사용할 때 final이 필요한 이유는 변수의 수명이 다르기 때문입니다. 지역 변수는 메서드가 끝나면 사라지지만, 람다는 나중에 실행될 수 있어서 외부 변수가 중간에 바뀌면 람다가 실행될 때 예상과 다른 값을 사용할 수 있습니다.

- final을 사용하면 변수 값이 바뀌지 않음을 보장해서 안전하게 람다에서 사용할 수 있고, 코드를 읽는 사람도 이 변수는 바뀌지 않는다는 것을 쉽게 알 수 있습니다.

- Java 8 이후로는 final 없이도 사용할 수 있지만, 명시적으로 final을 붙이는 것이 좋습니다.

</details>

# 9. GC

<details>
<summary>Java의 GC에 대해 설명해 주세요.</summary>

- 가비지 컬렉션은 JVM의 Heap 영역에서 필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스입니다. 

- 핵심 특징으로는 자동 메모리 관리가 있습니다. C나 C++과 달리 프로그래머가 수동으로 메모리 할당과 해제를 하지 않아도 되고, 메모리 누수 방지로 개발자가 메모리 관리에 신경 쓰지 않고 개발에 집중할 수 있습니다. 또한 객체 참조 상태 기반으로 객체가 참조되고 있는 상태 여부로 제거 대상을 결정합니다.

- 다양한 GC 알고리즘을 설정을 통해 Java에 적용할 수 있고, Serial, Parallel, CMS, G1, ZGC 등이 있습니다. 다른 언어에도 내장되어 있어서 파이썬, 자바스크립트, GO 언어 등에도 GC 기능이 내장되어 있습니다.

- 단점으로는 예측 불가능성으로 메모리가 정확히 언제 해제되는지 알 수 없어 제어하기 어렵고, STW로 GC 동작 중에는 다른 동작이 멈춰 오버헤드가 발생하며, CPU 오버헤드로 GC 자체가 CPU 자원을 사용한다는 점이 있습니다.

</details>

<details>
<summary>finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?</summary>

- finalize()는 GC에 의해 객체가 제거될 때 자동으로 실행되는 메서드입니다. 

- 수동 호출 시 문제점:
  - 예측 불가한 실행: 어떤 스레드가 실행하는지 예측이 불가능
  - GC 스케줄링 방해: GC가 객체를 수집하지 않으려 하여 정상적으로 호출되지 않을 수 있음
  - 객체 부활: finalize()에서 객체를 다시 참조하게 되면 예상치 못하게 객체가 다시 살아날 수 있음
  - 동시성 문제: 여러 스레드에서 동시에 호출 시 동시성 문제가 야기될 수 있음
  - 보안 취약: finalize() 내의 예외는 JVM에 의해 잡히지 않음

- 대안: finalize() 대신 Cleaner나 AutoCloseable 인터페이스를 사용하고, try-with-resources 문법을 활용하는 것이 좋습니다.

</details>

<details>
<summary>어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?</summary>

- 상황에 따라 GC가 될 가능성이 있습니다. (“변수가 null이 되었다 = 무조건 GC 대상”은 아니고, 실제로는 해당 객체를 참조하는 다른 경로가 존재하는지 여부가 핵심)

- GC 대상이 되는 경우:
  - 객체가 null인 경우: 참조가 끊어진 객체
  - 블록 실행 종료 후: 블록 내에서 생성된 객체
  - 부모 객체가 null인 경우: 포함되는 자식 객체

- GC 대상이 되지 않는 경우:
  - null이 되었지만 다른 참조가 남아있는 경우: 다른 변수나 객체가 여전히 참조하고 있는 경우

</details>

# 10. equals와 hashCode

<details>
<summary>equals()와 hashcode()에 대해 설명해 주세요.</summary>

- equals()는 객체 간 논리적 동등성을 비교하는 메서드입니다. 기본적으로 Object 클래스의 equals() 메서드는 '==' 연산자와 동일하게 참조 비교를 수행하고, 객체 내용을 비교하려면 equals()를 오버라이딩해야 합니다.

- hashCode()는 객체의 해시 값을 반환하는 메서드로, HashMap, HashSet, HashTable 등에서 사용됩니다. 주의점은 equals()가 true를 반환하는 객체들은 반드시 hashCode()도 동일한 값을 반환해야 한다는 것입니다.

</details>

<details>
<summary>본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?</summary>

- equals()와의 일관성을 유지할 수 있도록 equals()가 true를 반환한 경우 hashCode()도 동일해야 한다는 것입니다. 객체가 변하지 않았을 때 해시 값도 변하지 않도록 고려하여 작성할 것 같습니다.

- 또한 좋은 해시 분포를 위해 다양한 값들이 균등하게 분포되도록 구현하고, 빠른 계산이 가능하도록 효율적인 알고리즘을 사용하며, null 값에 대한 안전한 처리를 해야 합니다. 해시 충돌의 경우 equals()가 달라도 hashCode() 값은 같을 수 있으므로 LinkedList 형태로 객체를 추가하는 방식을 고려해야 합니다.

</details>

<details>
<summary>그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.</summary>

- 5가지 일반 규약을 준수해야 합니다:
  - 반사성: x.equals(x)는 true
  - 대칭성: x.equals(y)가 true면 y.equals(x)도 true
  - 추이성: x.equals(y)가 true이고 y.equals(z)가 true면 x.equals(z)도 true
  - 일관성: x.equals(y)를 여러 번 호출해도 항상 같은 결과
  - null 아님: x.equals(null)은 false

- hashCode() 계약으로 반드시 hashCode()도 재정의해야 하고, instanceof 연산자로 올바른 타입인지 확인해야 합니다. fail-fast 최적화로 가능하면 getClass() 대신 instanceof를 사용하여 상속 관계를 고려해야 합니다.

</details>

# 11. IoC와 DI

<details>
<summary>IoC와 DI에 대해 설명해 주세요.</summary>

- IoC(Inversion of Control, 제어의 역전)는 개발자가 직접 관리하던 객체의 생성과 제어 흐름을 프레임워크나 컨테이너에 위임한다는 개념입니다. 객체의 생성, 초기화, 생명 주기 관리 등을 프레임워크가 처리하고, IoC 컨테이너(스프링 컨테이너)에 의해 관리됩니다.

- DI(Dependency Injection, 의존성 주입)는 빈 설정 정보를 바탕으로 컨테이너가 외부에서 객체를 생성해 필요한 클래스에 주입하는 패턴입니다. IoC의 구현 방식 중 하나입니다. DI를 사용하면 클래스 간의 의존 관계가 명확해지고, 테스트하기 쉬우며, 코드의 유연성이 높아집니다.
  - 생성자 주입: 객체 생성 시점에 의존성을 주입받아 한 번 설정되면 변경 불가
  - 수정자 주입: setter 메서드를 통해 언제든지 의존성을 변경 가능
  - 필드 주입: @Autowired를 필드에 직접 붙여서 주입받는 방식

</details>

<details>
<summary>후보 없이 특정 기능을 하는 클래스가 딱 한 개라라면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?</summary>

% 구체 클래스: 추상화되지 않은 실제 구현체

- 맞습니다. 그런 경우 구체 클래스를 직접 사용해도 된다고 생각합니다. 하지만 Spring에서 여전히 Bean을 등록해서 사용하는 것이 더 좋은 이유가 있습니다.

- 싱글톤 관리로 객체가 한 번만 생성되어 재사용되는 싱글톤 빈으로 관리되어 불필요한 객체 생성을 방지하고 성능 최적화를 할 수 있습니다. DI를 통한 결합도 감소로 타클래스 의존성을 낮출 수 있고, 객체 생명 주기 관리로 스프링이 객체의 생명 주기를 관리합니다. 부가 기능 추가로 로깅, 트랜잭션과 같은 부가 기능을 쉽게 추가할 수 있으며, 테스트 용이성으로 모킹과 테스트가 용이합니다.

</details>

<details>
<summary>Spring의 Bean 생성 주기에 대해 설명해 주세요.</summary>

- 스프링 Bean의 생명 주기는 스프링 컨테이너 생성부터 시작해서 Bean 생성, 의존성 주입, 초기화 콜백, Bean 사용, 소멸전 콜백을 거쳐 스프링 종료까지 진행됩니다.

- 초기화 콜백은 Bean이 생성되고 의존성 주입이 완료된 후에 호출되어 Bean이 사용되기 전 필요한 초기화 작업을 수행합니다.

- 소멸 전 콜백은 스프링이 종료되기 전에 호출되어 Bean이 소멸되기 전 정리 작업을 수행합니다.

</details>

<details>
<summary>프로토타입 빈은 무엇인가요?</summary>

- 프로토타입 빈은 스프링에서 빈을 등록하면 기본적으로 싱글톤으로 만들어지는데, 이를 싱글톤이 아닌 하나의 빈으로 여러 개의 객체를 만들고 싶을 때 사용하는 것입니다.

- 특징으로는 매번 새로운 인스턴스를 요청할 때마다 새로운 객체를 생성하고, 생명 주기는 스프링 컨테이너가 관리하지 않습니다.

- 사용 시 주의사항으로는 @Resource나 @Autowired 등으로 의존관계 주입 후 프로토타입 빈을 가져오려면 싱글톤 빈처럼 작동하기 때문에 ApplicationContext.getBean()을 사용해서 다른 객체를 가져와야 합니다. 생명 주기가 관리되는 스프링 빈과 달리, 프로토타입 빈은 개발자가 직접 관리해야 합니다.

</details>

# 12. AOP

<details>
<summary>AOP에 대해 설명해 주세요.</summary>
</details>

<details>
<summary>@Aspect는 어떻게 동작하나요?</summary>
</details>

# 13. Interceptor와 Filter

<details>
<summary>Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.</summary>
</details>

<details>
<summary>설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?</summary>
</details>

# 14. DispatcherServlet

<details>
<summary>DispatcherServlet 의 역할에 대해 설명해 주세요.</summary>
</details>

<details>
<summary>여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?</summary>
</details>

<details>
<summary>수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?</summary>
</details>

# 15. ORM

<details>
<summary>JPA와 같은 ORM을 사용하는 이유가 무엇인가요?</summary>
</details>

<details>
<summary>영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?</summary>
</details>

<details>
<summary>N + 1 문제에 대해 설명해 주세요.</summary>
</details>

# 16. Transactional

<details>
<summary>@Transactional 은 어떤 기능을 하나요?</summary>
</details>

<details>
<summary>@Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?</summary>
</details>

<details>
<summary>그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?</summary>
</details>

# 17. Annotation

<details>
<summary>Java 에서 Annotation 은 어떤 기능을 하나요?</summary>
</details>

<details>
<summary>별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?</summary>
</details>

<details>
<summary>Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?</summary>
</details>

# 18. Tomcat

<details>
<summary>Tomcat이 정확히 어떤 역할을 하는 도구인가요?</summary>
</details>

<details>
<summary>혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?</summary>
</details>